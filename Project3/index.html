<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CS180/280A · Project 3A — Image Warping & Mosaicing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --max: 980px; }
    * { box-sizing: border-box; }
    body { margin: 24px; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; line-height: 1.6; background:#fafafa;}
    main, header, footer { max-width: var(--max); margin: 0 auto; }
    h1, h2, h3 { line-height: 1.25; }
    .muted { color:#666; font-size: 14px; }
    .pair, .row { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 14px; margin:14px 0;}
    figure { margin: 0; border: 1px solid #eaeaea; border-radius: 10px; padding: 10px; background: #fff; }
    figcaption { margin-top: 6px; font-size: 14px; color: #555; }
    img { max-width: 100%; height: auto; display: block; background: #f5f5f5; border-radius: 6px; }
    nav a, .toc a { text-decoration: none; color:#2f6feb; }
    hr { border: none; height: 1px; background: #eee; margin: 28px 0; }
    .tight figure { padding:6px; }
    .wide figure img { width:100%; }
    .downloads a { display:inline-block; margin-right:12px; font-size:14px; }
    .grid-3 { display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap:14px; }
  </style>
</head>
<body>
  <header>
    <p class="muted"><a href="../index.html">← Back to Home</a></p>
    <h1>Project 3A — Image Warping & Mosaicing</h1>
    <p class="muted">CS180/280A · Your Name · Fall 2025</p>
  </header>

  <main>
    <!-- TOC -->
    <section class="toc">
      <p>
        <a href="#overview">Overview</a> ·
        <a href="#a1">A.1 Shoot the Pictures</a> ·
        <a href="#a2">A.2 Recover Homographies</a> ·
        <a href="#a3">A.3 Warp the Images & Rectification</a> ·
        <a href="#a4">A.4 Blend into a Mosaic</a> ·
        <a href="#a5">A.5 Bells & Whistles</a>
      </p>
    </section>

    <hr />

    <!-- ============== OVERVIEW ============== -->
    <section id="overview">
      <h2>Project Overview</h2>
      <div class="prompt">
        <p>
          In this project, we explore image warping and mosaicing — a classic problem in computer vision. 
          The main goal is to align and blend multiple photographs into a single seamless mosaic by computing geometric transformations between them. 
          Through this process, we implement key concepts such as <em>homography estimation</em>, <em>image warping</em> with both nearest-neighbor and bilinear interpolation, 
          and <em>image blending</em> for smooth transitions across boundaries.
        </p>
        <p>
          The project consists of several parts: first capturing suitable images with overlapping fields of view, then recovering homographies between pairs of images using manually selected correspondences. 
          Next, we perform inverse warping to align images under projective transformations and experiment with rectification to verify correctness. 
          Finally, we blend the warped images into mosaics using weighted averaging or feathering techniques, and optionally extend to <em>cylindrical projection</em> for wide panoramas.
        </p>
  
      </div>
    </section>


    <hr />

    <!-- ============== A1 ============== -->
    <section id="a1">
      <h2>A.1 Shoot the Pictures</h2>
      <div class="prompt">
        <p>
          This set of photos captures the sunset canyon scenery at the classic scenic spot in Yellowstone National Park.
        </p>
      </div>
      <div class="row">
        <figure>
          <img src="./data/river1.jpeg" alt="river1 original" />
          <figcaption>left, canyon (source)</figcaption>
        </figure>
        <figure>
          <img src="./data/river2.jpeg" alt="river2 original" />
          <figcaption>medium, canyon (source)</figcaption>
        </figure>
        <figure>
          <img src="./data/river3.jpeg" alt="river3 original" />
          <figcaption>right, canyon (source)</figcaption>
        </figure>
      </div>
    </section>

    <hr />

    <!-- ============== A2 ============== -->
    <section id="a2">
      <h2>A.2 Recover Homographies</h2>
      <div class="prompt">
        <p>
            To align two images, we first need to estimate the projective transformation between them, represented by a 3×3 homography matrix. 
    I implemented <code>computeH(im1_pts, im2_pts)</code> based on the normalized Direct Linear Transform (DLT) algorithm. 
    The method takes pairs of manually selected correspondences from two images, normalizes their coordinates to improve numerical stability, 
    constructs an overdetermined linear system <code>Ah = 0</code>, and solves it using singular value decomposition (SVD). 
    The resulting matrix is then denormalized to produce the final homography. 
        </p>
      </div>
      <pre><code>
def computeH(im1_pts, im2_pts, use_normalization=True):
    im1_pts = np.asarray(im1_pts, dtype=np.float64)
    im2_pts = np.asarray(im2_pts, dtype=np.float64)
    assert im1_pts.shape == im2_pts.shape and im1_pts.shape[0] >= 4
    if use_normalization:
        T1, p1 = normalize_points(im1_pts)
        T2, p2 = normalize_points(im2_pts)
    else:
        T1, p1 = np.eye(3), im1_pts
        T2, p2 = np.eye(3), im2_pts
    A = build_A_normDLT(p1, p2)
    _,_,Vt = np.linalg.svd(A, full_matrices=False)
    Hn = Vt[-1].reshape(3,3)
    H = np.linalg.inv(T2) @ Hn @ T1
    if abs(H[2,2]) > 1e-12: H = H / H[2,2]
    return H
    </code></pre>
      
      <figure>
          <img src="./result/2_correspond.png" alt="corr" />
          <figcaption>Correspondence Visualization, left and medium, width="500"</figcaption>
        </figure>
      <!-- A.2 · Text 2 -->
      <p>
      H =
      <pre>
      [[ 1.312538  0.091343 -604.306458]
       [ 0.199424  1.271263 -163.161362]
       [ 0.000249  0.000053   1.000000]]
      mean reprojection error: 1.942 px
      </pre>
      </p>
      
      <div class="answer">
        <p>
        The estimated homography aligns the two river images accurately with an average reprojection error under 2 pixels. 
        The transformation captures both rotation and perspective distortion, as seen from the horizontal shift and slight scaling across the canyon. 
        The correspondences (shown above) match key geometric structures, confirming that the normalization and least-squares SVD approach effectively recovered a stable mapping.
        </p>
      </div>

    </section>

    

    <hr />

    <!-- ============== A3 ============== -->
    <section id="a3">
      <h2>A.3 Warp the Images &amp; Rectification</h2>


      <!-- A.3 · Text 1 + Code -->
      <p>
      I warp images by inverse mapping with a precomputed homography. I first predict the output canvas by transforming the four source corners and build a shift transform so all warped pixels land at nonnegative coordinates. For each output pixel, I map back with H⁻¹ to sample the source. I implement two samplers: nearest neighbor (round to the closest pixel) and bilinear (weighted average of four neighbors). Both return an alpha mask indicating valid samples, which is useful for preview overlays and later blending. I also save the warped RGB and the alpha images for comparison and rectification checks.
      </p>

<details>
  <summary>Show Code</summary>
  <pre><code>
def warpImageNearestNeighbor(im, H, out_shape=None, out_T=None):
    if out_shape is None or out_T is None:
        out_shape, T = make_canvas_and_transform(im.shape, H)
    else:
        T = out_T
    Htot = T @ H
    Hinv = np.linalg.inv(Htot)
    oh, ow = out_shape
    yy, xx = np.meshgrid(np.arange(oh), np.arange(ow), indexing="ij")
    tgt = np.stack([xx, yy, np.ones_like(xx)], axis=-1).reshape(-1,3)
    src = (Hinv @ tgt.T).T
    src_xy = src[:,:2] / src[:,2:3]
    su = np.rint(src_xy[:,0]).astype(int)
    sv = np.rint(src_xy[:,1]).astype(int)
    h, w = im.shape[:2]
    inside = (su>=0)&(su<w)&(sv>=0)&(sv<h)
    out = np.zeros((oh, ow, im.shape[2] if im.ndim==3 else 1), dtype=np.float32)
    if im.ndim==3:
        out = out.reshape(-1,3)
        out[inside] = im[sv[inside], su[inside]]
        out = out.reshape(oh, ow, 3)
    else:
        out = out.reshape(-1,1)
        out[inside,0] = im[sv[inside], su[inside]]
        out = out.reshape(oh, ow)
    alpha = inside.astype(np.float32).reshape(oh, ow)
    return out, alpha, T

def warpImageBilinear(im, H, out_shape=None, out_T=None):
    if out_shape is None or out_T is None:
        out_shape, T = make_canvas_and_transform(im.shape, H)
    else:
        T = out_T
    Htot = T @ H
    Hinv = np.linalg.inv(Htot)
    oh, ow = out_shape
    yy, xx = np.meshgrid(np.arange(oh), np.arange(ow), indexing="ij")
    tgt = np.stack([xx, yy, np.ones_like(xx)], axis=-1).reshape(-1,3)
    src = (Hinv @ tgt.T).T
    uv = src[:,:2] / src[:,2:3]
    u = uv[:,0]; v = uv[:,1]
    x0 = np.floor(u).astype(int); x1 = x0 + 1
    y0 = np.floor(v).astype(int); y1 = y0 + 1
    ax = u - x0; ay = v - y0
    h, w = im.shape[:2]
    valid = (x0>=0)&(x1<w)&(y0>=0)&(y1<h)
    out = np.zeros((oh, ow, im.shape[2] if im.ndim==3 else 1), dtype=np.float32).reshape(-1, -1 if False else (3 if im.ndim==3 else 1))
    if im.ndim==3:
        I00 = np.zeros((tgt.shape[0],3), np.float32); I10 = I00.copy(); I01 = I00.copy(); I11 = I00.copy()
        idx = valid.nonzero()[0]
        if idx.size:
            I00[idx] = im[y0[idx], x0[idx]]
            I10[idx] = im[y0[idx], x1[idx]]
            I01[idx] = im[y1[idx], x0[idx]]
            I11[idx] = im[y1[idx], x1[idx]]
        w00 = (1-ax)*(1-ay); w10 = ax*(1-ay); w01 = (1-ax)*ay; w11 = ax*ay
        out = (I00*w00[:,None] + I10*w10[:,None] + I01*w01[:,None] + I11*w11[:,None])
        out = out.reshape(oh, ow, 3)
    else:
        I00 = np.zeros((tgt.shape[0],1), np.float32); I10 = I00.copy(); I01 = I00.copy(); I11 = I00.copy()
        idx = valid.nonzero()[0]
        if idx.size:
            I00[idx,0] = im[y0[idx], x0[idx]]
            I10[idx,0] = im[y0[idx], x1[idx]]
            I01[idx,0] = im[y1[idx], x0[idx]]
            I11[idx,0] = im[y1[idx], x1[idx]]
        w00 = (1-ax)*(1-ay); w10 = ax*(1-ay); w01 = (1-ax)*ay; w11 = ax*ay
        out = (I00*w00[:,None] + I10*w10[:,None] + I01*w01[:,None] + I11*w11[:,None]).reshape(oh, ow)
    alpha = valid.astype(np.float32).reshape(oh, ow)
    return out, alpha, T

  </code></pre>
</details>

      <h3>Nearest Neighbor Warping</h3>
      
      <div class="row">
        <figure>
          <img src="./result/im1_warp_to_im2_nn.png" alt="im1 warp to im2 (nearest neighbor)" />
          <figcaption>im1_warp_to_im2_nn.png</figcaption>
        </figure>
        <figure>
          <img src="./result/3_overlay_nn.png" alt="im1 warp to im2 (NN) with alpha" />
          <figcaption>im1_warp_to_im2_nn_alpha.png</figcaption>
        </figure>
      </div>

      <h3>Bilinear Warping</h3>
      <div class="row">
        <figure>
          <img src="./result/3_overlay_bl.png" alt="im1 warp to im2 (bilinear)" />
          <figcaption>im1_warp_to_im2_bilinear.png</figcaption>
        </figure>
        <figure>
          <img src="./result/im1_warp_to_im2_bilinear_alpha.png" alt="im1 warp to im2 (bilinear) with alpha" />
          <figcaption>im1_warp_to_im2_bilinear_alpha.png</figcaption>
        </figure>
      </div>

      <!-- Rectification examples can be inserted here when exported -->
    </section>

    <hr />

    <!-- ============== A4 ============== -->
    <section id="a4">
      <h2>A.4 Blend the Images into a Mosaic</h2>
      <div class="row">
        <figure>
          <img src="./result/mosaic_river12_im1warped.png" alt="mosaic: im1 warped into im2" />
          <figcaption>mosaic_river12_im1warped.png</figcaption>
        </figure>
        <figure>
          <img src="./result/mosaic_river12_im2oncanvas.png" alt="mosaic: im2 on canvas" />
          <figcaption>mosaic_river12_im2oncanvas.png</figcaption>
        </figure>
        <figure>
          <img src="./result/mosaic_river12.png" alt="mosaic blended result" />
          <figcaption>mosaic_river12.png</figcaption>
        </figure>
      </div>
    </section>

    <hr />

    <!-- ============== A5 ============== -->
    <section id="a5">
      <h2>A.5 Bells &amp; Whistles</h2>
      <div class="wide">
        <figure>
          <img src="./result/cylindrical_panorama_river123.png" alt="cylindrical panorama river123" />
          <figcaption>cylindrical_panorama_river123.png</figcaption>
        </figure>
      </div>
    </section>

  </main>

  <footer>
    <p class="muted">© <span id="y"></span> · CS180/280A · <a href="../index.html">Home</a></p>
  </footer>

  <script>document.getElementById('y').textContent = new Date().getFullYear();</script>
</body>
</html>

